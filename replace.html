<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>황치환</title>
    <style>
        button {
        background-color: black;
        color: #8888aa;
        font-size: 1em;
        font-weight: bold;
        border-radius: 0.2em;
        }
        label {
        font-size: 1em;
        font-weight: bold;
        }
        div{
        margin-top:0.5em;
        }
        textarea {
            width: 50%;
            height: 512px;
        }
        .container {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        .button-container {
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <textarea id="leftText" placeholder="여기에 입력"></textarea>
        <textarea id="rightText" placeholder="결과"></textarea>
    </div>
    <div class="button-container">
        <div>
            <button onclick="Func00()">왼쪽으로 이동</button>
            <button onclick="Func01()">오른쪽을 복사</button>
            <input type="checkbox" id="auto01" name="auto01">
            <label for="auto01">오른쪽 복사 자동</label>
            <input type="checkbox" id="auto02" name="auto02">
            <label for="auto02">오른쪽 파일 저장 자동</label>
        </div>
        <div>
            <input id="ipt_1" placeholder="1" style="width:166px;">
            <input id="ipt_2" placeholder="2" style="width:166px;">
            <input id="ipt_3" placeholder="3" style="width:166px;">
            <button onclick="Func02()">문장 뒤 공백 제거</button>
            <button onclick="Func03()">탭을 공백4칸으로</button>
            <button onclick="Func04()">1내용2</button>
            <button onclick="Func08()">1양식</button>
            <br>
            <button onclick="Func10()">pgTb→TbHis</button>
            <button onclick="Func11()">pgTb→fn_Tb</button>
            <button onclick="Func12()">pgTb→fn_TbHis</button>
            <button onclick="Func13()">pgTb→Tb.cs</button>
            <button onclick="Func14()">pgTb→fn_Tb.cs</button>
            <br>
            <button onclick="Func20()">MsSQL→pgTb</button>
            <button onclick="Func21()">123QMS→pgTb</button>
            <button onclick="Func22()">12MMADDOCS→pgTb</button>
        </div>
    </div>

    <script>
		// 타입 변환 함수들
		function convertMsPg(mssqlType) {
			mssqlType = mssqlType.toLowerCase();
			if (mssqlType.startsWith('nvarchar') || mssqlType.startsWith('varchar')) return 'text';
			if (mssqlType.startsWith('int')) return 'integer';
			if (mssqlType.startsWith('datetime')) return 'timestamp without time zone';
			if (mssqlType.startsWith('numeric')) {
				const m = mssqlType.match(/numeric\s*\(\s*\d+(\s*,\s*\d+)?\s*\)/i);
				if (m) return m[0].toLowerCase();
				return 'numeric(15,4)'; // fallback
			}
			return 'text';
		}
		function convertDotnetPg(dotNetType) {
			switch (dotNetType) {
				case 'String': return 'text';
				case 'Int32': return 'integer';
				case 'Int64': return 'bigint';
				case 'Single': return 'real';
				case 'Double': return 'double precision';
				case 'Decimal': return 'numeric';
				case 'Boolean': return 'boolean';
				case 'DateTime':
				case 'DateTimeOffset': return 'timestamp with time zone';
				case 'DateOnly': return 'date';
				case 'TimeOnly': return 'time';
				case 'Guid': return 'uuid';
				case 'List`1': return 'text[]';
				case 'Dictionary`2': return 'jsonb';
				default: return dotNetType;
			}
		}
        function Auto01() {
            if (document.getElementById("auto01").checked) {
                Func01();
            }
        }
        function Auto02(fileName) {
            if (document.getElementById("auto02").checked) {
				// 브라우저에서 파일로 저장
				const blob = new Blob([rightText.value], { type: "text/plain" });
				const url = URL.createObjectURL(blob);
				const a = document.createElement("a");
				a.href = url;
				a.download = fileName;
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				URL.revokeObjectURL(url);
            }
        }
        function Func00() {
            let rightTextVal = rightText.value;

            leftText.value = rightTextVal;
            rightText.value = "";
        }
        function Func01() {
            rightText.select();
            document.execCommand('copy');
            leftText.focus();
        }
        function Func02() {
            let leftTextVal = leftText.value;

            leftTextVal = leftTextVal.replace(/[ \t]+$/gm, '');

            rightText.value = leftTextVal;

            Auto01();
        }
        function Func03() {
            let leftTextVal = leftText.value;

            leftTextVal = leftTextVal.replace(/\t/g, "    ");

            rightText.value = leftTextVal;

            Auto01();
        }
        function Func04() {
            let leftTextVal = leftText.value;

            leftTextVal = leftTextVal.replace(/^(.+)$/gm, ipt_1.value + '$1' + ipt_2.value);

            rightText.value = leftTextVal;

            Auto01();
        }
        function Func08() {
            function pad(num) {
                return num.toString().padStart(2, "0");
            }
            function yyyyMMdd(date){
                return date.getFullYear()+"-"+pad(date.getMonth() + 1)+"-"+pad(date.getDate());
            }
            function yyyyMMdd2(date){
                const map = {
                  1: '월',
                  2: '화',
                  3: '수',
                  4: '목',
                  5: '금',
                  6: '토',
                  7: '일'
                };
                return date.getFullYear()+"."+pad(date.getMonth() + 1)+"."+pad(date.getDate())
                    + " " + map[date.getDay()] + "요일"
            }
            let date = new Date();
            rightText.value = ipt_1.value + " " + yyyyMMdd(date) + " 일일 업무보고서\n";
            rightText.value += yyyyMMdd2(date) + "\n";
            
            let date2 = new Date();
            date2.setDate(date2.getDate() - 4);
            let start = date2.getDate();
            let end = date.getDate();
            rightText.value += ipt_1.value + " " + date.getFullYear() + "/" + pad(date.getMonth() + 1) + " " + start + "~" + end + "일 주간업무보고\n";
            
            rightText.value += ipt_1.value + " " + yyyyMMdd(date) + " 휴가신청서(오후반차)\n";
            rightText.value += ipt_1.value + " " + yyyyMMdd(date) + " 지출결의서\n";
            Auto01();
        }
        function Func10() {
			  let ddl = leftText.value;

  // 1. 원본 테이블명 추출
  const tableNameMatch = ddl.match(/CREATE TABLE IF NOT EXISTS\s+([^\s(]+)/i);
  if (!tableNameMatch) throw new Error("테이블명을 찾을 수 없음");

  const fullTableName = tableNameMatch[1];
  const schema = fullTableName.includes(".") ? fullTableName.split(".")[0] : "public";
  const baseName = fullTableName.includes(".") ? fullTableName.split(".")[1] : fullTableName;

  const historyTableName = `${schema}.${baseName}_history`;

  // 2. 모든 baseName → baseName_history 치환 (테이블명, 제약조건 등)
  ddl = ddl.replace(new RegExp(baseName, "g"), `${baseName}_history`);

  // 3. CREATE TABLE 내부 컬럼 추출
  const createTableMatch = ddl.match(/CREATE TABLE IF NOT EXISTS [\s\S]*?\(([\s\S]*?)\)\s*TABLESPACE/);
  if (!createTableMatch) throw new Error("CREATE TABLE 구문을 찾을 수 없음");

  let columns = createTableMatch[1].trim();

  // 4. 기존 PK/Unique/Constraint 제거 (줄 단위)
  columns = columns
    .split("\n")
    .filter(line => !/CONSTRAINT/i.test(line.trim()))
    .join("\n");

  // 5. 히스토리 전용 컬럼 추가 (맨 앞)
  const historyCols = `    his_uuid bigint NOT NULL,
    his_dm timestamp without time zone NOT NULL,
    his_state text NOT NULL,`;
  columns = historyCols + "\n    " + columns;

  // 6. CREATE TABLE 정의문 다시 작성
  ddl = ddl.replace(
    /CREATE TABLE IF NOT EXISTS [\s\S]*?\([\s\S]*?\)\s*TABLESPACE/,
    `CREATE TABLE IF NOT EXISTS ${historyTableName}\n(\n${columns}\n    CONSTRAINT ${baseName}_history_pkey PRIMARY KEY (his_dm, his_uuid)\n)\n\nTABLESPACE`
  );

  // 7. COMMENT ON COLUMN: 새 컬럼 추가
  ddl += `
COMMENT ON COLUMN ${historyTableName}.his_uuid IS '변경내역UUID';
COMMENT ON COLUMN ${historyTableName}.his_dm IS '변경일시';
COMMENT ON COLUMN ${historyTableName}.his_state IS '변경상태';
`;

  // 8. COMMENT ON TABLE: _history + ' 변경내역'
  ddl = ddl.replace(
    /COMMENT ON TABLE\s+([^\s]+)\s+IS\s+'([^']+)';/gi,
    (match, tableName, comment) => {
      const historyTable = tableName + "_history";
      return `COMMENT ON TABLE ${historyTable} IS '${comment} 변경내역';`;
    }
  );

            rightText.value = ddl;

            Auto01();
        }
function Func11() {
    let ddl = leftText.value;

    // 테이블명 추출
    const tableNameMatch = ddl.match(/CREATE TABLE IF NOT EXISTS\s+([^\s(]+)/i);
    if (!tableNameMatch) throw new Error("테이블명을 찾을 수 없습니다.");
    const fullTableName = tableNameMatch[1];
    const baseName = fullTableName.includes(".") ? fullTableName.split(".")[1] : fullTableName;

    // 컬럼 추출
    const columnsMatch = ddl.match(/CREATE TABLE [\s\S]*?\(([\s\S]*?)\)/i);
    if (!columnsMatch) throw new Error("컬럼을 찾을 수 없습니다.");

    let columns = columnsMatch[1]
        .split("\n")
        .map(line => line.trim())
        .filter(line => line && !line.toUpperCase().startsWith("CONSTRAINT"))
        .map(line => line.replace(/,$/, ''))
        .map(line => line.split(/\s+/)[0]);

    // PK/Unique 컬럼 추출
    const pkMatch = ddl.match(/PRIMARY KEY\s*\(([^)]+)\)/i);
    const pkCols = pkMatch ? pkMatch[1].split(",").map(c => c.trim()) : [];

    const uniqueMatches = [...ddl.matchAll(/UNIQUE\s*\(([^)]+)\)/gi)];
    const uniqueCols = uniqueMatches.flatMap(m => m[1].split(",").map(c => c.trim()));

    const pkUniqueCols = [...new Set([...pkCols, ...uniqueCols])];

    // INSERT 컬럼 (upd_dm, upd_id 제외, reg_dm/NOW() 처리)
    const insertCols = columns.filter(c => !["upd_id","upd_dm"].includes(c));
    const insertValues = insertCols.map(c => {
        if (c === "reg_dm" || c === "upd_dm") return "NOW()";
        return `p_${c}`;
    }).join(",\n        ");

    // UPDATE 컬럼 (pk, unique, reg_id, reg_dm 제외, upd_dm/NOW() 처리)
    const updateCols = columns.filter(c => 
        !pkUniqueCols.includes(c) && !["reg_id","reg_dm"].includes(c)
    );
    const updateSet = updateCols.map(c => {
        if (c === "upd_dm") return `${c} = NOW()`;
        return `${c} = p_${c}`;
    }).join(",\n        ");

    // DISTINCT WHERE 절 (PK/Unique + reg/upd 컬럼 제외)
    const distinctCols = columns.filter(c => 
        !pkUniqueCols.includes(c) && !["reg_id","reg_dm","upd_id","upd_dm"].includes(c)
    );
    const distinctWhere = distinctCols.map(c => `${fullTableName}.${c} IS DISTINCT FROM p_${c}`).join("\n       OR ");

    // p_ 컬럼 정의 (COLLATE 제거, 타입/제약 그대로 유지)
    const pColsDef = columnsMatch[1]
        .split("\n")
        .map(line => line.trim())
        .filter(line => line && !line.toUpperCase().startsWith("CONSTRAINT"))
        .map(line => line.replace(/,$/, ''))
        .map(line => {
            let parts = line.replace(/COLLATE pg_catalog\."default"/gi, '').trim();
            let colName = parts.split(/\s+/)[0];
            let colType = parts.slice(colName.length).trim();
            return `p_${colName} ${colType}`;
        })
        .join(",\n    ");

    // PERFORM 히스토리용 컬럼 줄바꿈 (p_reg_dm → NOW(), p_upd_dm → NULL)
    const performCols = columns.map(c => {
        if (c === "reg_dm") return "NOW()";
        if (c === "upd_dm") return "NULL";
        return `p_${c}`;
    }).join(",\n        ");

    // 함수 문자열 생성
    rightText.value = `
CREATE OR REPLACE FUNCTION public.fn_${baseName}(
    ${pColsDef},
    p_act_type text
)
RETURNS TABLE(r_${columns[0]} bigint)
LANGUAGE plpgsql
AS $BODY$
DECLARE
    v_state text;
    v_action int;
BEGIN
    IF p_${columns[0]} IS NULL THEN
        p_${columns[0]} := seq(); -- 시퀀스 생성
    END IF;

    v_state := UPPER(p_act_type);
    IF v_state = 'D' THEN
        p_inact_yn := 'Y';
    ELSE
        p_inact_yn := 'N';
    END IF;

    INSERT INTO ${fullTableName}(
        ${insertCols.join(",\n        ")}
    )
    VALUES (
        ${insertValues}
    )
    ON CONFLICT ON CONSTRAINT ${baseName}_pkey
    DO UPDATE SET
        ${updateSet}
    WHERE ${distinctWhere}
    RETURNING xmax INTO v_action;

    -- 히스토리 호출
    PERFORM fn_${baseName}_history(
        v_state,
        ${performCols}
    );

    RETURN QUERY
    SELECT p_${columns[0]};

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error: %', SQLERRM;
END;
$BODY$;
`;

    Auto01();
}

        function Func12() {
let ddl = leftText.value;

// 테이블명 추출
const tableNameMatch = ddl.match(/CREATE TABLE IF NOT EXISTS\s+([^\s(]+)/i);
if (!tableNameMatch) throw new Error("테이블명을 찾을 수 없습니다.");
const fullTableName = tableNameMatch[1];
const baseName = fullTableName.includes(".") ? tableNameMatch[1].split(".")[1] : tableNameMatch[1];
const historyTable = `${baseName}_history`;

// 컬럼 추출
const columnsMatch = ddl.match(/CREATE TABLE [\s\S]*?\(([\s\S]*?)\)/i);
if (!columnsMatch) throw new Error("컬럼을 찾을 수 없습니다.");

let columns = columnsMatch[1]
  .split("\n")
  .map(line => line.trim())
  .filter(line => line && !line.toUpperCase().startsWith("CONSTRAINT"))
  .map(line => line.replace(/,$/, ''))
  .map(line => line.split(/\s+/)[0]);

// p_ 컬럼 정의 (COLLATE 제거)
const pColsDef = columnsMatch[1]
  .split("\n")
  .map(line => line.trim())
  .filter(line => line && !line.toUpperCase().startsWith("CONSTRAINT"))
  .map(line => line.replace(/,$/, ''))
  .map(line => {
    let parts = line.replace(/COLLATE pg_catalog\."default"/gi, '').trim();
    let colName = parts.split(/\s+/)[0];
    let colType = parts.slice(colName.length).trim();
    return `p_${colName} ${colType}`;
  })
  .join(",\n    ");

// INSERT 컬럼, VALUES (upd_id, upd_dm 제외, reg_dm → NOW())
const insertCols = ["his_uuid", "his_dm", "his_state", ...columns.filter(c => !["upd_id","upd_dm"].includes(c))];
const insertValues = ["v_his_uuid", "NOW()", "p_his_state", ...columns.filter(c => !["upd_id","upd_dm"].includes(c)).map(c => c === "reg_dm" ? "NOW()" : `p_${c}`)].join(",\n        ");

// 함수 생성
rightText.value = `
CREATE OR REPLACE FUNCTION public.fn_${baseName}_history(
    p_his_state text,
    ${pColsDef}
)
RETURNS TABLE(r_his_uuid bigint) 
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_his_uuid bigint;
BEGIN
    v_his_uuid := ccode();

    INSERT INTO ${historyTable}(
        ${insertCols.join(",\n        ")}
    )
    VALUES (
        ${insertValues}
    );

    RETURN QUERY
    SELECT v_his_uuid;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error: %', SQLERRM;
END;
$BODY$;
`;
            Auto01();
		}
        function Func13() {
let sql = leftText.value;

// CREATE TABLE 구문부터 시작하도록 앞부분 제거
sql = sql.replace(/^[\s\S]*?(CREATE TABLE[\s\S]*)$/i, "$1");

// 테이블명 추출
const classNameMatch = sql.match(/CREATE TABLE(?: IF NOT EXISTS)? public\.(\w+)/i);
const className = classNameMatch ? classNameMatch[1].toUpperCase() : "UNKNOWN";

// 테이블 COMMENT 추출
let tableComment = className;
const tableCommentMatch = sql.match(/COMMENT ON TABLE public\.\w+\s+IS\s+'([^']+)'/i);
if (tableCommentMatch) {
    tableComment = tableCommentMatch[1];
}

// PK 컬럼 추출
const pkMatches = [...sql.matchAll(/PRIMARY KEY\s*\((.*?)\)/gi)]
    .flatMap(m => m[1].split(",").map(c => c.trim().toUpperCase()));
const notNullCols = new Set(pkMatches);

// COMMENT 매핑
const comments = {};
[...sql.matchAll(/COMMENT ON COLUMN public\.\w+\.(\w+)\s+IS\s+'([^']+)'/gi)]
    .forEach(m => {
        comments[m[1].toUpperCase()] = m[2];
    });

// --- 핵심: CREATE TABLE (...) 안에 들어있는 컬럼 정의만 추출 ---
const tableDefMatch = sql.match(/CREATE TABLE[\s\S]*?\(([\s\S]*?)\)[\s\S]*;/i);
const tableDef = tableDefMatch ? tableDefMatch[1] : "";

// 컬럼 정의만 추출
const columnRegex = /^\s*(\w+)\s+([\w\s\(\)]+)/gmi;
let match;
const columns = [];
while ((match = columnRegex.exec(tableDef)) !== null) {
    const colName = match[1].toUpperCase();
    if (["CONSTRAINT","PRIMARY","UNIQUE"].includes(colName)) continue;

    const colType = match[2].trim().toLowerCase();
    let csType;

    if (/int|numeric|real|bigint/.test(colType)) {
        csType = "decimal";
    } else {
        csType = "string";
    }

    // PK, UNIQUE → 무조건 not null, 그 외 → nullable 허용
    const nullable = notNullCols.has(colName) ? "" : "?";

    columns.push({
        name: colName,
        type: csType + nullable,
        desc: comments[colName] || colName
    });
}

rightText.value = `using System.ComponentModel;

namespace HS.Web.RabbitMQApi
{
    [Description("${tableComment}")]
    public class ${className}
    {
${columns.map(c =>
`        [Description("${c.desc}")]
        public ${c.type} ${c.name} { get; set; }`
).join("\n\n")}
    }
}`;
			Auto01();
            Auto02(`${className}.cs`);
		}
        function Func14() {
let sql = leftText.value;

// CREATE TABLE 구문부터 시작
sql = sql.replace(/^[\s\S]*?(CREATE TABLE[\s\S]*)$/i, "$1");

// 테이블명 추출
const classNameMatch = sql.match(/CREATE TABLE IF NOT EXISTS public\.(\w+)/i);
const className = classNameMatch ? classNameMatch[1].toLowerCase() : "unknown";

// 컬럼 정의 추출 (CONSTRAINT, TABLESPACE 등 제외)
const columnRegex = /^\s*(\w+)\s+([\w\s\(\)]+)(?:COLLATE.*)?(?:NOT NULL)?/gmi;
let match;
const columns = [];
while ((match = columnRegex.exec(sql)) !== null) {
    const colName = match[1].toUpperCase();
    if (["CONSTRAINT","TABLESPACE","ALTER","OWNER","COMMENT","CREATE"].includes(colName)) continue;

    const colType = match[2].trim().toLowerCase();
    let suffix;
    if (/int|numeric|real|bigint/.test(colType)) suffix = ".D";
    else if (/timestamp|date/.test(colType)) suffix = ".DT";
    else suffix = ".V";

    columns.push({
        name: colName,
        suffix: suffix
    });
}

// REG_DM, UPD_DM은 NULL
const columnsForProc = columns.map(c => {
    if (c.name === "REG_DM" || c.name === "UPD_DM") return "            NULL";
    return `            {Data["${c.name}"]${c.suffix}}`; // 공백 12칸으로 통일
}).join(",\n        ");

rightText.value = `using HS.Core;
using HS.Web.Common;
using System.Text;

namespace HS.Web.Proc
{
    public class fn_${className}
    {
        /// <summary>
        /// 공통 저장프로시저
        /// </summary>
        /// <param name="Data"></param>
        /// <returns></returns>
        public static string Proc(Params Data)
        {
            StringBuilder sSQL = new StringBuilder();

            DTClient.UserInfoMerge(Data);

            sSQL.Append($@"
                SELECT * FROM fn_${className}
                (
        ${columnsForProc}
                );
            ");

            return sSQL.ToString();
        }

        /// <summary>
        /// 공통 저장프로시저 (리스트)
        /// </summary>
        /// <param name="DataList"></param>
        /// <returns></returns>
        public static string Proc(ParamList DataList)
        {
            StringBuilder sSQL = new StringBuilder();

            DataList.ForEach(ITEM =>
            {
                sSQL.Append(Proc(ITEM));
            });

            return sSQL.ToString();
        }

        /// <summary>
        /// 공통 저장
        /// </summary>
        /// <param name="Data"></param>
        /// <returns></returns>
        public static Params Save(Params Data)
        {
            StringBuilder sSQL = new StringBuilder();

            sSQL.Append(Proc(Data));

            return HS.Web.Common.Data.Result("PG", sSQL.ToString());
        }

        /// <summary>
        /// 공통 저장 (리스트)
        /// </summary>
        /// <param name="DataList"></param>
        /// <returns></returns>
        public static Params Save(ParamList DataList)
        {
            StringBuilder sSQL = new StringBuilder();

            sSQL.Append(Proc(DataList));

            return HS.Web.Common.Data.Result("PG", sSQL.ToString());
        }
    }
}
`;

			Auto01();
            Auto02(`${className}.cs`);
		}
		function Func20() {
// leftText.value에 MSSQL CREATE TABLE 문자열이 들어있다고 가정
const lines = leftText.value.trim().split(/\r?\n/).map(l => l.trim()).filter(l => l);

// 테이블명 추출 (CREATE TABLE [DB].[Schema].[TableName] 또는 CREATE TABLE TableName)
let tableName = '';
const tableLine = lines.find(l => l.toUpperCase().startsWith('CREATE TABLE'));
if (tableLine) {
    const match = tableLine.match(/CREATE TABLE\s+(\[?[\w]+\]?\.)?\[?[\w]+\]?\.(\w+)/i)
              || tableLine.match(/CREATE TABLE\s+(\w+)/i);
    if (match) tableName = (match[2] || match[1]).toLowerCase();
}

// 컬럼 정의만 추출 (괄호 안쪽)
const startIdx = lines.findIndex(l => l.includes('('));
const endIdx = lines.findIndex(l => l.includes(');'));
const colLines = lines.slice(startIdx + 1, endIdx);

// 첫 번째 컬럼 이름 → 첫 컬럼 id
let firstCol = colLines[0].split(/\s+/)[0].toLowerCase();
let firstColId = tableName.split('_').map(p => p[0]).join('') + '_id';

// 컬럼 변환
let pgCols = [`${firstColId} bigint NOT NULL`];
colLines.forEach(line => {
    if (/^constraint/i.test(line)) return; // 제약조건 라인은 건너뜀
    let [colName, ...rest] = line.replace(/,/, '').split(/\s+/);
    let colType = rest.join(' ');
    pgCols.push(`${colName.toLowerCase()} ${convertMsPg(colType)}`);
});

// 마지막 5개 컬럼 추가
pgCols.push(
    'reg_id text',
    'reg_dm timestamp without time zone',
    'upd_id text',
    'upd_dm timestamp without time zone',
    'inact_yn text'
);

// PK 제약조건 추출
let pkLine = lines.find(l => /primary key/i.test(l));
let pkConstraint = '';
if (pkLine) {
    const m = pkLine.match(/\(([^)]+)\)/); // 괄호 안 컬럼
    if (m) {
        const pkCols = m[1].split(',').map(c => c.trim().toLowerCase()).join(',');
        pkConstraint = `CONSTRAINT ${tableName}_pkey PRIMARY KEY (${pkCols})`;
    }
}

// 최종 CREATE TABLE 문자열 생성
let constraints = [];
if (pkConstraint) constraints.push(pkConstraint);
constraints.push(`CONSTRAINT ${tableName}_${firstColId}_key UNIQUE (${firstColId})`);

rightText.value = `CREATE TABLE IF NOT EXISTS ${tableName} (\n    ${pgCols.join(',\n    ')},\n    ${constraints.join(',\n    ')}\n);\n\n` +
`COMMENT ON COLUMN ${tableName}.reg_id IS '등록자';\n` +
`COMMENT ON COLUMN ${tableName}.reg_dm IS '등록일시';\n` +
`COMMENT ON COLUMN ${tableName}.upd_id IS '수정자';\n` +
`COMMENT ON COLUMN ${tableName}.upd_dm IS '수정일시';\n` +
`COMMENT ON COLUMN ${tableName}.inact_yn IS '데이터제외구분';`;

			Auto01();
		}
		function Func21() {
			const lines = leftText.value.trim().split('\n');
			if (lines.length < 1) return;

			// 테이블명 (스네이크 케이스)
			const tableName = ipt_1.value.replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase();
			const unique = tableName.replace(/(^|_)([a-z])[a-z]*/g, "$2") + "_id";

			const columns = [];
			const comments = [];

			// 기본 컬럼
			columns.push(unique + " bigint");
			comments.push(`COMMENT ON TABLE ${tableName} IS '${ipt_2.value}';`);

			// 사용자 입력 컬럼
			for (let i = 0; i < lines.length; i++) {
				const parts = lines[i].split('\t').map(p => p.trim());
				if (parts.length < 3) continue;

				const columnName = parts[0].toLowerCase();
				const dataType = convertDotnetPg(parts[1]);
				const comment = parts[4] || parts[2];

				columns.push(`${columnName} ${dataType}`);
				comments.push(`COMMENT ON COLUMN ${tableName}.${columnName} IS '${comment}';`);
			}

			// 공통 컬럼 및 제약조건
			columns.push("reg_id text");
			columns.push("reg_dm timestamp");
			columns.push("upd_id text");
			columns.push("upd_dm timestamp");
			columns.push("inact_yn text");
			columns.push(`CONSTRAINT ${tableName}_pkey PRIMARY KEY (${ipt_3.value})`);
			columns.push(`CONSTRAINT ${tableName}_${unique}_key UNIQUE (${unique})`);

			comments.push(`COMMENT ON COLUMN ${tableName}.reg_id IS '등록자';`);
			comments.push(`COMMENT ON COLUMN ${tableName}.reg_dm IS '등록일시';`);
			comments.push(`COMMENT ON COLUMN ${tableName}.upd_id IS '수정자';`);
			comments.push(`COMMENT ON COLUMN ${tableName}.upd_dm IS '수정일시';`);
			comments.push(`COMMENT ON COLUMN ${tableName}.inact_yn IS '데이터제외구분';`);

			// CREATE TABLE 문 생성
			const createTableQuery = `CREATE TABLE IF NOT EXISTS ${tableName} (\n  ${columns.join(',\n  ')}\n);`;
			const commentQuery = comments.join('\n');

			rightText.value = createTableQuery + "\n" + commentQuery;

			Auto01();
		}
function Func22() {
    const tableName = ipt_1.value;

    // 첫 번째 컬럼 생성: 테이블명에서 _로 나누고 첫 글자 따서 id 붙이기
    const firstColName = tableName.split('_').map(p => p[0]).join('') + "_id";

    const lines = leftText.value.split('\n');
    let columns = [`${firstColName} bigint NOT NULL,`]; // 첫 번째 컬럼
    let comments = [];

    lines.forEach(line => {
        const parts = line.split('\t').map(p => p.trim());
        if(parts.length < 2) return;

        // $.payload.data[]. 혹은 $.data[]. 제거
        let colName = parts[0].replace(/^\$\.(payload\.)?data\[\]\./, '');
        let pgType = convertMsPg(parts[1]); // 기존 convertMsPg 함수 사용
        let notNull = parts[2] === 'N' ? ' NOT NULL' : '';

        columns.push(`${colName} ${pgType}${notNull},`);

        // 주석 처리: parts[3]가 없으면 빈 문자열도 허용
        const commentText = parts[3] ? parts[3] : '';
        comments.push(`COMMENT ON COLUMN ${tableName}.${colName} IS '${commentText}';`);
    });

    // 고정 컬럼 추가
    columns.push(
        `reg_id text COLLATE pg_catalog."default",`,
        `reg_dm timestamp without time zone,`,
        `upd_id text COLLATE pg_catalog."default",`,
        `upd_dm timestamp without time zone,`,
        `inact_yn text COLLATE pg_catalog."default"`
    );

    comments.push(
        `COMMENT ON COLUMN ${tableName}.reg_id IS '등록자';`,
        `COMMENT ON COLUMN ${tableName}.reg_dm IS '등록일시';`,
        `COMMENT ON COLUMN ${tableName}.upd_id IS '수정자';`,
        `COMMENT ON COLUMN ${tableName}.upd_dm IS '수정일시';`,
        `COMMENT ON COLUMN ${tableName}.inact_yn IS '데이터제외구분';`
    );

    // 마지막 쉼표 제거
    if(columns.length > 0) {
        const lastIndex = columns.length - 1;
        columns[lastIndex] = columns[lastIndex].replace(/,$/, '');
    }

    // 테이블 생성 + 제약조건 (CREATE TABLE 안에서)
    columns.push(
        `CONSTRAINT ${tableName}_pkey PRIMARY KEY (asst_cd, revision_no, asst_group_cd, company),`,
        `CONSTRAINT ${tableName}_${firstColName}_key UNIQUE (${firstColName})`
    );

    const createTable = `CREATE TABLE ${tableName} (\n${columns.map(c => '    ' + c).join('\n')}\n);\n`;

    rightText.value = createTable + '\n' + comments.join('\n');

    Auto01();
}
    </script>
</body>
</html>
