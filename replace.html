<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>황치환</title>
    <style>
        button {
        background-color: black;
        color: #8888aa;
        font-size: 1em;
        font-weight: bold;
        border-radius: 0.2em;
        }
        label {
        font-size: 1em;
        font-weight: bold;
        }
        div{
        margin-top:0.5em;
        }
        textarea {
            width: 50%;
            height: 512px;
        }
        .container {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        .button-container {
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <textarea id="leftText" placeholder="여기에 입력"></textarea>
        <textarea id="rightText" placeholder="결과"></textarea>
    </div>
    <div class="button-container">
        <div>
            <button onclick="Func00()">왼쪽으로 이동</button>
            <button onclick="Func01()">오른쪽을 복사</button>
            <input type="checkbox" id="auto01" name="auto01">
            <label for="auto01">오른쪽 복사 자동</label>
            <input type="checkbox" id="auto02" name="auto02">
            <label for="auto02">오른쪽 파일 저장 자동</label>
        </div>
        <div>
            <input id="ipt_1" placeholder="1" style="width:166px;">
            <input id="ipt_2" placeholder="2" style="width:166px;">
            <input id="ipt_3" placeholder="3" style="width:166px;">
            <button onclick="Func02()">문장 뒤 공백 제거</button>
            <button onclick="Func03()">탭을 공백4칸으로</button>
			<button onclick="Func06()">\n을 엔터로</button>
            <button onclick="Func04()">1내용2</button>
            <button onclick="Func05()">Json Pretty</button>
            <button onclick="Func08()">1양식</button>
            <br>
            <button onclick="Func10()">pgTb→TbHis</button>
            <button onclick="Func11()">pgTb→fn_Tb</button>
            <button onclick="Func12()">pgTb→fn_TbHis</button>
            <button onclick="Func13()">pgTb→Tb.cs</button>
            <button onclick="Func14(1)">pgTb→fn_Tb.cs(대)</button>
            <button onclick="Func14(2)">pgTb→fn_Tb.cs(소)</button>
            <br>
            <button onclick="Func20()">MsSQL→pgTb</button>
            <button onclick="Func21()">123QMS→pgTb</button>
            <button onclick="Func22()">12MMADDOCS→pgTb</button>
        </div>
    </div>

    <script>
        // 타입 변환 함수들
        function convertMsPg(mssqlType) {
            mssqlType = mssqlType.toLowerCase();
            if (mssqlType.startsWith('nvarchar') || mssqlType.startsWith('varchar')) return 'text';
            if (mssqlType.startsWith('int')) return 'integer';
            if (mssqlType.startsWith('datetime')) return 'timestamp without time zone';
            if (mssqlType.startsWith('numeric')) {
                const m = mssqlType.match(/numeric\s*\(\s*\d+(\s*,\s*\d+)?\s*\)/i);
                if (m) return m[0].toLowerCase();
                return 'numeric(15,4)'; // fallback
            }
            return 'text';
        }
        function convertDotnetPg(dotNetType) {
            switch (dotNetType) {
                case 'String': return 'text';
                case 'Int32': return 'integer';
                case 'Int64': return 'bigint';
                case 'Single': return 'real';
                case 'Double': return 'double precision';
                case 'Decimal': return 'numeric';
                case 'Boolean': return 'boolean';
                case 'DateTime':
                case 'DateTimeOffset': return 'timestamp with time zone';
                case 'DateOnly': return 'date';
                case 'TimeOnly': return 'time';
                case 'Guid': return 'uuid';
                case 'List`1': return 'text[]';
                case 'Dictionary`2': return 'jsonb';
                default: return dotNetType;
            }
        }
        function parseDdl(ddl) {
            ddl = ddl.replace(/COLLATE\s+pg_catalog\."default"/gi, "");

            const result = {};

            const tableMatch = ddl.match(/CREATE TABLE IF NOT EXISTS\s+([^\s(]+)/i);
            if (!tableMatch) return null;
            result.fullTableName = tableMatch[1];
            result.schema = result.fullTableName.includes(".") ? result.fullTableName.split(".")[0] : "public";
            result.baseName = result.fullTableName.includes(".") ? result.fullTableName.split(".")[1] : result.fullTableName;

            // 테이블 COMMENT
            const tableCommentMatch = ddl.match(/COMMENT ON TABLE\s+[^\s]+\s+IS\s+'([^']+)'/i);
            result.tableComment = tableCommentMatch ? tableCommentMatch[1] : result.baseName;

            // PK
            const pkMatch = ddl.match(/PRIMARY KEY\s*\(([^)]+)\)/i);
            result.primaryKey = pkMatch ? pkMatch[1].split(",").map(s => s.trim()) : [];

            // Unique Keys
            const uniqueMatches = [...ddl.matchAll(/UNIQUE\s*\(([^)]+)\)/gi)];
            result.uniqueKeys = uniqueMatches.map(m => m[1].split(",").map(s => s.trim()));

            // 컬럼 정의
            const startIdx = ddl.indexOf('(');
            const endIdx = ddl.lastIndexOf(')');
            if (startIdx === -1 || endIdx === -1 || startIdx >= endIdx) return null;
            const colBlock = ddl.slice(startIdx + 1, endIdx);

            const colRegex = /^\s*([a-zA-Z0-9_]+)\s+(.+?)(?=,\s*\n)/gmi;
            result.columns = [];
            let match;
            while ((match = colRegex.exec(colBlock)) !== null) {
                const colName = match[1];
                const colType = match[2].trim();
                if (["CONSTRAINT", "PRIMARY", "UNIQUE"].includes(colName.toUpperCase())) continue;

                // COMMENT
                const commentRegex = new RegExp(`COMMENT ON COLUMN ${result.fullTableName}\\.${colName}\\s+IS\\s+'([^']+)'`, "i");
                const commentMatch = ddl.match(commentRegex);

                result.columns.push({
                    name: colName,
                    type: colType,
                    comment: commentMatch ? commentMatch[1] : colName
                });
            }
            console.log(result);
            return result;
        }
        function Auto01() {
            if (document.getElementById("auto01").checked) {
                Func01();
            }
        }
        function Auto02(fileName) {
            if (document.getElementById("auto02").checked) {
                // 브라우저에서 파일로 저장
                const blob = new Blob([rightText.value], { type: "text/plain" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }
        function Func00() {
            let rightTextVal = rightText.value;

            leftText.value = rightTextVal;
            rightText.value = "";
        }
        function Func01() {
            rightText.select();
            document.execCommand('copy');
            leftText.focus();
        }
        function Func02() {
            let leftTextVal = leftText.value;

            leftTextVal = leftTextVal.replace(/[ \t]+$/gm, '');

            rightText.value = leftTextVal;

            Auto01();
        }
        function Func03() {
            let leftTextVal = leftText.value;

            leftTextVal = leftTextVal.replace(/\t/g, "    ");

            rightText.value = leftTextVal;

            Auto01();
        }
        function Func06() {
            let leftTextVal = leftText.value;

            leftTextVal = leftTextVal.replace(/\\n/g, "\n");

            rightText.value = leftTextVal;

            Auto01();
        }
        function Func04() {
            let leftTextVal = leftText.value;

            leftTextVal = leftTextVal.replace(/^(.+)$/gm, ipt_1.value + '$1' + ipt_2.value);

            rightText.value = leftTextVal;

            Auto01();
        }
        function Func05() {
            let leftTextVal = leftText.value;

            try{
                rightText.value = JSON.stringify(JSON.parse(leftTextVal), null, 2);
            } catch(e){
                rightText.value = "Not a valid JSON.\nCheck your syntax!";
            }
            Auto01();
        }
        function Func08() {
            function pad(num) {
                return num.toString().padStart(2, "0");
            }
            function yyyyMMdd(date){
                return date.getFullYear()+"-"+pad(date.getMonth() + 1)+"-"+pad(date.getDate());
            }
            function yyyyMMdd2(date){
                const map = {
                  1: '월',
                  2: '화',
                  3: '수',
                  4: '목',
                  5: '금',
                  6: '토',
                  7: '일'
                };
                return date.getFullYear()+"."+pad(date.getMonth() + 1)+"."+pad(date.getDate())
                    + " " + map[date.getDay()] + "요일"
            }
            let date = new Date();
            rightText.value = ipt_1.value + " " + yyyyMMdd(date) + " 일일 업무보고서\n";
            rightText.value += yyyyMMdd2(date) + "\n";

            let date2 = new Date();
            date2.setDate(date2.getDate() - 4);
            let start = date2.getDate();
            let end = date.getDate();
            rightText.value += ipt_1.value + " " + date.getFullYear() + "/" + pad(date.getMonth() + 1) + " " + start + "~" + end + "일 주간업무보고\n";

            rightText.value += ipt_1.value + " " + yyyyMMdd(date) + " 휴가신청서(오후반차)\n";
            rightText.value += ipt_1.value + " " + yyyyMMdd(date) + " 지출결의서\n";
            Auto01();
        }
// --- Func10: pgTb → TbHis ---
function Func10() {
    const ddl = leftText.value;
    const info = parseDdl(ddl);
    if (!info) { rightText.value = "parseDdl 실패"; return; }

    const { schema, baseName, fullTableName, tableComment, columns } = info;
    const historyTable = `${schema}.${baseName}_history`;



    const hisCols = [
        { name: "his_uuid", type: "bigint NOT NULL", comment: "변경내역UUID" },
        { name: "his_dm", type: "timestamp without time zone NOT NULL", comment: "변경일시" },
        { name: "his_state", type: "text NOT NULL", comment: "변경상태" }
    ];
    const allCols = [...hisCols, ...columns];
    const colDefs = allCols.map(c => `    ${c.name} ${c.type}`).join(",\n");

    let ddlOut = `CREATE TABLE IF NOT EXISTS ${historyTable}
(
${colDefs},
    CONSTRAINT ${baseName}_history_pkey PRIMARY KEY (his_dm, his_uuid)
)
TABLESPACE pg_default;`;

    ddlOut += `\n\nCOMMENT ON TABLE ${historyTable} IS '${tableComment} 변경내역';\n`;
    allCols.forEach(c => {
        ddlOut += `COMMENT ON COLUMN ${historyTable}.${c.name} IS '${c.comment}';\n`;
    });

    rightText.value = ddlOut.trim();
    Auto01();
}

// --- Func11: pgTb → fn_Tb ---
function Func11() {
    const ddl = leftText.value;
    const info = parseDdl(ddl);
    if (!info) { rightText.value = "parseDdl 실패"; return; }

    const { fullTableName, baseName, columns, primaryKey, uniqueKeys } = info;
    const pkUniqueCols = [...new Set([...primaryKey, ...uniqueKeys.flat()])];

    const insertCols = columns.filter(c => c.name !== "upd_dm");
    const insertNames = insertCols.map(c => c.name);
    const insertValues = insertCols.map(c => c.name === "reg_dm" ? "NOW()" : `p_${c.name}`);

    const updateCols = columns.filter(c =>
        !pkUniqueCols.includes(c.name) && !["reg_id", "reg_dm"].includes(c.name)
    );
    const updateSet = updateCols.map(c =>
        c.name === "upd_dm" ? `${c.name} = NOW()` : `${c.name} = p_${c.name}`
    );

    const distinctCols = columns.filter(c =>
        !pkUniqueCols.includes(c.name) && !["reg_id","reg_dm","upd_id","upd_dm"].includes(c.name)
    );
    const distinctWhere = distinctCols.map(c => `${fullTableName}.${c.name} IS DISTINCT FROM p_${c.name}`);

    const pColsDef = columns.map(c => `p_${c.name} ${c.type.replaceAll(/DEFAULT.*/g,"").replaceAll(/NOT NULL.*/g, "").trim()}`).join(",\n    ");

    rightText.value = `CREATE OR REPLACE FUNCTION public.fn_${baseName}(
    ${pColsDef},
    p_act_type text
)
RETURNS TABLE(r_${columns[0].name} bigint)
LANGUAGE plpgsql
AS $BODY$
DECLARE
    v_state text;
    v_action bigint;
BEGIN
    IF p_${columns[0].name} IS NULL THEN
        p_${columns[0].name} := seq();
    END IF;

    v_state := UPPER(p_act_type);
    IF v_state = 'D' THEN
        p_inact_yn := 'Y';
    ELSE
        p_inact_yn := 'N';
    END IF;

    INSERT INTO ${fullTableName}(
        ${insertNames.join(",\n        ")}
    ) VALUES (
        ${insertValues.join(",\n        ")}
    )
    ON CONFLICT ON CONSTRAINT ${baseName}_pkey
    DO UPDATE SET
        ${updateSet.join(",\n        ")}
    WHERE ${distinctWhere.join("\n       OR ")}
    RETURNING xmax INTO v_action;

    IF v_action IS NOT NULL THEN
        PERFORM fn_${baseName}_history(
            CASE WHEN v_action = 0 THEN 'C' ELSE 'U' END,
            ${columns.map(c => `p_${c.name}`).join(",\n            ")}
        );
    END IF;

    RETURN QUERY
    SELECT p_${columns[0].name};
END;
$BODY$;`;
    Auto01();
}

// --- Func12: pgTb → fn_TbHis ---
function Func12() {
    const ddl = leftText.value;
    const info = parseDdl(ddl);
    if (!info) { rightText.value = "parseDdl 실패"; return; }

    const { baseName, columns } = info;
    const historyTable = `${baseName}_history`;

    const pColsDef = columns.map(c => `p_${c.name} ${c.type.replaceAll(/DEFAULT.*/g,"").replaceAll(/NOT NULL.*/g, "").trim()}`).join(",\n    ");

    const insertCols = ["his_uuid","his_dm","his_state",...columns.map(c => c.name)];
    const insertValues = ["v_his_uuid","NOW()","p_his_state",...columns.map(c =>
        c.name === "reg_dm" ? "NOW()" : `p_${c.name}`
    )];

    rightText.value = `CREATE OR REPLACE FUNCTION public.fn_${baseName}_history(
    p_his_state text,
    ${pColsDef}
)
RETURNS TABLE(r_his_uuid bigint)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_his_uuid bigint;
BEGIN
    v_his_uuid := ccode();

    INSERT INTO ${historyTable}(
        ${insertCols.join(",\n        ")}
    ) VALUES (
        ${insertValues.join(",\n        ")}
    );

    RETURN QUERY
    SELECT v_his_uuid;
END;
$BODY$;`;
    Auto01();
}

// --- Func13: pgTb → Tb.cs ---
function Func13() {
    const ddl = leftText.value;
    const info = parseDdl(ddl);
    if (!info) { rightText.value = "parseDdl 실패"; return; }

    const { baseName, tableComment, columns, primaryKey } = info;
    const className = baseName.toUpperCase();

    const colsForCs = columns.map(col => {
        const typeLower = col.type.toLowerCase();
        let csType = "string";
        if (typeLower.includes("int") || typeLower.includes("numeric") || typeLower.includes("real")) csType = "decimal";
        else if (typeLower.includes("numeric") || typeLower.includes("decimal")) csType = "decimal";
        return {
            name: col.name.toUpperCase(),
            csType: csType + (primaryKey.includes(col.name) ? "" : "?"),
            desc: col.comment || col.name
        };
    });

    rightText.value = `using System.ComponentModel;

namespace HS.Web.RabbitMQApi
{
    [Description("${tableComment || className}")]
    public class ${className}
    {
${colsForCs.map(c =>
`        [Description("${c.desc}")]
        public ${c.csType} ${c.name} { get; set; }`).join("\n\n")}
    }
}`;
    Auto01();
}

// --- Func14: pgTb → fn_Tb.cs ---
function Func14(upper_lower) {
    const ddl = leftText.value;
    const info = parseDdl(ddl);
    if (!info) { rightText.value = "parseDdl 실패"; return; }

    const columns = [];

    for(e of info.columns){
        if(["reg_id","reg_dm","upd_id","upd_dm","inact_yn"].includes(e.name)){
            continue;
        }
        let dv = "V";
        if(e.type.includes("int") || e.type.includes("numeric") || e.type.includes("real")){
            dv = "D";
        } else if(e.type.includes("timestamp") || e.type.includes("date")){
            dv = "DT";
        }
		if(upper_lower == 1){
			columns.push(`{Data["${e.name.toUpperCase()}"].${dv}}`);
		} else {
			columns.push(`{Data["${e.name.toLowerCase()}"].${dv}}`);
		}
    }

    rightText.value = `using HS.Core;
using HS.Web.Common;
using System.Text;

namespace HS.Web.Proc
{
    public class fn_${info.baseName}
    {
        /// <summary>
        /// 공통 저장프로시저
        /// </summary>
        /// <param name="Data"></param>
        /// <returns></returns>
        public static string Proc(Params Data)
        {
            StringBuilder sSQL = new StringBuilder();

            DTClient.UserInfoMerge(Data);

            sSQL.Append($@"
                SELECT * FROM fn_${info.baseName}
                (
                    ${(columns.join(",\n                    "))},
                    {Data["REG_ID"].V},
                    NULL,
                    {Data["UPD_ID"].V},
                    NULL,
                    {Data["INACT_YN"].V},
                    {Data["ACT_TYPE"].V}
                );
            ");

            return sSQL.ToString();
        }

        /// <summary>
        /// 공통 저장프로시저 (리스트)
        /// </summary>
        /// <param name="DataList"></param>
        /// <returns></returns>
        public static string Proc(ParamList DataList)
        {
            StringBuilder sSQL = new StringBuilder();

            DataList.ForEach(ITEM =>
            {
                sSQL.Append(Proc(ITEM));
            });

            return sSQL.ToString();
        }

        /// <summary>
        /// 공통 저장
        /// </summary>
        /// <param name="Data"></param>
        /// <returns></returns>
        public static Params Save(Params Data)
        {
            StringBuilder sSQL = new StringBuilder();

            sSQL.Append(Proc(Data));

            return HS.Web.Common.Data.Result("PG", sSQL.ToString());
        }

        /// <summary>
        /// 공통 저장 (리스트)
        /// </summary>
        /// <param name="DataList"></param>
        /// <returns></returns>
        public static Params Save(ParamList DataList)
        {
            StringBuilder sSQL = new StringBuilder();

            sSQL.Append(Proc(DataList));

            return HS.Web.Common.Data.Result("PG", sSQL.ToString());
        }

        /// <summary>
        /// 공통 저장
        /// </summary>
        /// <param name="DataList"></param>
        /// <returns></returns>
        public static async Task<Params> SaveAsync(Params Data)
        {
            StringBuilder sSQL = new StringBuilder();

            sSQL.Append(Proc(Data));

            return (await HS.Web.Common.Data.ResultAsync("PG", sSQL.ToString()));
        }

        /// <summary>
        /// 공통 저장 (리스트)
        /// </summary>
        /// <param name="DataList"></param>
        /// <returns></returns>
        public static async Task<Params> SaveAsync(ParamList DataList)
        {
            StringBuilder sSQL = new StringBuilder();

            sSQL.Append(Proc(DataList));

            return (await HS.Web.Common.Data.ResultAsync("PG", sSQL.ToString()));
        }
    }
}`;

    Auto01();
}
function Func20() {
// leftText.value에 MSSQL CREATE TABLE 문자열이 들어있다고 가정
const lines = leftText.value.trim().split(/\r?\n/).map(l => l.trim()).filter(l => l);

// 테이블명 추출 (CREATE TABLE [DB].[Schema].[TableName] 또는 CREATE TABLE TableName)
let tableName = '';
const tableLine = lines.find(l => l.toUpperCase().startsWith('CREATE TABLE'));
if (tableLine) {
    const match = tableLine.match(/CREATE TABLE\s+(\[?[\w]+\]?\.)?\[?[\w]+\]?\.(\w+)/i)
              || tableLine.match(/CREATE TABLE\s+(\w+)/i);
    if (match) tableName = (match[2] || match[1]).toLowerCase();
}

// 컬럼 정의만 추출 (괄호 안쪽)
const startIdx = lines.findIndex(l => l.includes('('));
const endIdx = lines.findIndex(l => l.includes(');'));
const colLines = lines.slice(startIdx + 1, endIdx);

// 첫 번째 컬럼 이름 → 첫 컬럼 id
let firstCol = colLines[0].split(/\s+/)[0].toLowerCase();
let firstColId = tableName.split('_').map(p => p[0]).join('') + '_id';

// 컬럼 변환
let pgCols = [`${firstColId} bigint NOT NULL`];
colLines.forEach(line => {
    if (/^constraint/i.test(line)) return; // 제약조건 라인은 건너뜀
    let [colName, ...rest] = line.replace(/,/, '').split(/\s+/);
    let colType = rest.join(' ');
    pgCols.push(`${colName.toLowerCase()} ${convertMsPg(colType)}`);
});

// 마지막 5개 컬럼 추가
pgCols.push(
    'reg_id text',
    'reg_dm timestamp without time zone',
    'upd_id text',
    'upd_dm timestamp without time zone',
    'inact_yn text'
);

// PK 제약조건 추출
let pkLine = lines.find(l => /primary key/i.test(l));
let pkConstraint = '';
if (pkLine) {
    const m = pkLine.match(/\(([^)]+)\)/); // 괄호 안 컬럼
    if (m) {
        const pkCols = m[1].split(",").map(c => c.trim().toLowerCase()).join(',');
        pkConstraint = `CONSTRAINT ${tableName}_pkey PRIMARY KEY (${pkCols})`;
    }
}

// 최종 CREATE TABLE 문자열 생성
let constraints = [];
if (pkConstraint) constraints.push(pkConstraint);
constraints.push(`CONSTRAINT ${tableName}_${firstColId}_key UNIQUE (${firstColId})`);

rightText.value = `CREATE TABLE IF NOT EXISTS ${tableName} (\n    ${pgCols.join(',\n    ')},\n    ${constraints.join(',\n    ')}\n);\n\n` +
`COMMENT ON COLUMN ${tableName}.reg_id IS '등록자';\n` +
`COMMENT ON COLUMN ${tableName}.reg_dm IS '등록일시';\n` +
`COMMENT ON COLUMN ${tableName}.upd_id IS '수정자';\n` +
`COMMENT ON COLUMN ${tableName}.upd_dm IS '수정일시';\n` +
`COMMENT ON COLUMN ${tableName}.inact_yn IS '데이터제외구분';`;

            Auto01();
        }
        function Func21() {
            const lines = leftText.value.trim().split('\n');
            if (lines.length < 1) return;

            // 테이블명 (스네이크 케이스)
            const tableName = ipt_1.value.replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase();
            const unique = tableName.replace(/(^|_)([a-z])[a-z]*/g, "$2") + "_id";

            const columns = [];
            const comments = [];

            // 기본 컬럼
            columns.push(unique + " bigint");
            comments.push(`COMMENT ON TABLE ${tableName} IS '${ipt_2.value}';`);

            // 사용자 입력 컬럼
            for (let i = 0; i < lines.length; i++) {
                const parts = lines[i].split('\t').map(p => p.trim());
                if (parts.length < 3) continue;

                const columnName = parts[0].toLowerCase();
                const dataType = convertDotnetPg(parts[1]);
                const comment = parts[4] || parts[2];

                columns.push(`${columnName} ${dataType}`);
                comments.push(`COMMENT ON COLUMN ${tableName}.${columnName} IS '${comment}';`);
            }

            // 공통 컬럼 및 제약조건
            columns.push("reg_id text");
            columns.push("reg_dm timestamp");
            columns.push("upd_id text");
            columns.push("upd_dm timestamp");
            columns.push("inact_yn text");
            columns.push(`CONSTRAINT ${tableName}_pkey PRIMARY KEY (${ipt_3.value})`);
            columns.push(`CONSTRAINT ${tableName}_${unique}_key UNIQUE (${unique})`);

            comments.push(`COMMENT ON COLUMN ${tableName}.reg_id IS '등록자';`);
            comments.push(`COMMENT ON COLUMN ${tableName}.reg_dm IS '등록일시';`);
            comments.push(`COMMENT ON COLUMN ${tableName}.upd_id IS '수정자';`);
            comments.push(`COMMENT ON COLUMN ${tableName}.upd_dm IS '수정일시';`);
            comments.push(`COMMENT ON COLUMN ${tableName}.inact_yn IS '데이터제외구분';`);

            // CREATE TABLE 문 생성
            const createTableQuery = `CREATE TABLE ${tableName} (\n${columns.map(c => '    ' + c).join(',\n')}\n);\n`;

            rightText.value = createTableQuery + '\n' + comments.join('\n');

            Auto01();
        }
function Func22() {
    const tableName = ipt_1.value;

    // 첫 번째 컬럼 생성: 테이블명에서 _로 나누고 첫 글자 따서 id 붙이기
    const firstColName = tableName.split('_').map(p => p[0]).join('') + "_id";

    const lines = leftText.value.split('\n');
    let columns = [`${firstColName} bigint NOT NULL,`]; // 첫 번째 컬럼
    let comments = [];

    lines.forEach(line => {
        const parts = line.split('\t').map(p => p.trim());
        if(parts.length < 2) return;

        // $.payload.data[]. 혹은 $.data[]. 제거
        let colName = parts[0].replace(/^\$\.(payload\.)?data\[\]\./, '');
        let pgType = convertMsPg(parts[1]); // 기존 convertMsPg 함수 사용
        let notNull = parts[2] === 'N' ? ' NOT NULL' : '';

        columns.push(`${colName} ${pgType}${notNull},`);

        // 주석 처리: parts[3]가 없으면 빈 문자열도 허용
        const commentText = parts[3] ? parts[3] : '';
        comments.push(`COMMENT ON COLUMN ${tableName}.${colName} IS '${commentText}';`);
    });

    // 고정 컬럼 추가
    columns.push(
        `reg_id text,`,
        `reg_dm timestamp without time zone,`,
        `upd_id text,`,
        `upd_dm timestamp without time zone,`,
        `inact_yn text`
    );

    comments.push(
        `COMMENT ON COLUMN ${tableName}.reg_id IS '등록자';`,
        `COMMENT ON COLUMN ${tableName}.reg_dm IS '등록일시';`,
        `COMMENT ON COLUMN ${tableName}.upd_id IS '수정자';`,
        `COMMENT ON COLUMN ${tableName}.upd_dm IS '수정일시';`,
        `COMMENT ON COLUMN ${tableName}.inact_yn IS '데이터제외구분';`
    );

    // 마지막 쉼표 제거
    if(columns.length > 0) {
        const lastIndex = columns.length - 1;
        columns[lastIndex] = columns[lastIndex].replace(/,$/, '');
    }

    // 테이블 생성 + 제약조건 (CREATE TABLE 안에서)
    columns.push(
        `CONSTRAINT ${tableName}_pkey PRIMARY KEY (asst_cd, revision_no, asst_group_cd, company),`,
        `CONSTRAINT ${tableName}_${firstColName}_key UNIQUE (${firstColName})`
    );

    const createTable = `CREATE TABLE ${tableName} (\n${columns.map(c => '    ' + c).join('\n')}\n);\n`;

    rightText.value = createTable + '\n' + comments.join('\n');

    Auto01();
}
    </script>
</body>
</html>
