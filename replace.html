<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>황치환</title>
    <style>
        button {
        background-color: black;
        color: #8888aa;
        font-size: 1em;
        font-weight: bold;
        border-radius: 0.2em;
        }
        label {
        font-size: 1em;
        font-weight: bold;
        }
        div{
        margin-top:0.5em;
        }
        textarea {
            width: 50%;
            height: 512px;
        }
        .container {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        .button-container {
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <textarea id="leftText" placeholder="여기에 입력"></textarea>
        <textarea id="rightText" placeholder="결과"></textarea>
    </div>
    <div class="button-container">
        <div>
            <button onclick="Func00()">왼쪽으로 이동</button>
            <button onclick="Func01()">오른쪽을 복사</button>
            <input type="checkbox" id="auto01" name="auto01">
            <label for="auto01">오른쪽 복사 자동</label>
        </div>
        <div>
            <input id="ipt_1" placeholder="1" style="width:166px;">
            <input id="ipt_2" placeholder="2" style="width:166px;">
            <input id="ipt_3" placeholder="3" style="width:166px;">
            <input id="ipt_4" placeholder="4" style="width:166px;">
            <input id="ipt_5" placeholder="5" style="width:166px;">
            <button onclick="Func02()">문장 뒤 공백 제거</button>
            <button onclick="Func03()">탭을 공백4칸으로</button>
            <button onclick="Func04()">1내용2</button>
            <button onclick="Func08()">1양식</button>
            <br>
            <button onclick="Func10()">pgTb→TbHis</button>
            <button onclick="Func11()">pgTb→fn_Tb</button>
            <button onclick="Func12()">pgTb→fn_TbHis</button>
            <br>
            <button onclick="Func20()">123QMS→pgTb</button>
        </div>
    </div>

    <script>
        function Auto01() {
            if (document.getElementById("auto01").checked) {
                Func01();
            }
        }
        function Func00() {
            let rightTextVal = rightText.value;

            leftText.value = rightTextVal;
            rightText.value = "";
        }
        function Func01() {
            rightText.select();
            document.execCommand('copy');
            leftText.focus();
        }
        function Func02() {
            let leftTextVal = leftText.value;

            leftTextVal = leftTextVal.replace(/[ \t]+$/gm, '');

            rightText.value = leftTextVal;

            Auto01();
        }
        function Func03() {
            let leftTextVal = leftText.value;

            leftTextVal = leftTextVal.replace(/\t/g, "    ");

            rightText.value = leftTextVal;

            Auto01();
        }
        function Func04() {
            let leftTextVal = leftText.value;

            leftTextVal = leftTextVal.replace(/^(.+)$/gm, ipt_1.value + '$1' + ipt_2.value);

            rightText.value = leftTextVal;

            Auto01();
        }
        function Func08() {
            function pad(num) {
                return num.toString().padStart(2, "0");
            }
            function yyyyMMdd(date){
                return date.getFullYear()+"-"+pad(date.getMonth() + 1)+"-"+pad(date.getDate());
            }
            function yyyyMMdd2(date){
                const map = {
                  1: '월',
                  2: '화',
                  3: '수',
                  4: '목',
                  5: '금',
                  6: '토',
                  7: '일'
                };
                return date.getFullYear()+"."+pad(date.getMonth() + 1)+"."+pad(date.getDate())
                    + " " + map[date.getDay()] + "요일"
            }
            let date = new Date();
            rightText.value = ipt_1.value + " " + yyyyMMdd(date) + " 일일 업무보고서\n";
            rightText.value += yyyyMMdd2(date) + "\n";
            
            let date2 = new Date();
            date2.setDate(date2.getDate() - 4);
            let start = date2.getDate();
            let end = date.getDate();
            rightText.value += ipt_1.value + " " + date.getFullYear() + "/" + pad(date.getMonth() + 1) + " " + start + "~" + end + "일 주간업무보고\n";
            
            rightText.value += ipt_1.value + " " + yyyyMMdd(date) + " 휴가신청서(오후반차)\n";
            rightText.value += ipt_1.value + " " + yyyyMMdd(date) + " 지출결의서\n";
            Auto01();
        }
        function Func10() {
			  let ddl = leftText.value;

  // 1. 원본 테이블명 추출
  const tableNameMatch = ddl.match(/CREATE TABLE IF NOT EXISTS\s+([^\s(]+)/i);
  if (!tableNameMatch) throw new Error("테이블명을 찾을 수 없음");

  const fullTableName = tableNameMatch[1]; // 예: public.ci_asst100
  const schema = fullTableName.includes(".") ? fullTableName.split(".")[0] : "public";
  const baseName = fullTableName.includes(".") ? fullTableName.split(".")[1] : fullTableName;

  const historyTableName = `${schema}.${baseName}_history`;

  // 2. 모든 baseName → baseName_history 치환 (테이블명, 제약조건 등)
  ddl = ddl.replace(new RegExp(baseName, "g"), `${baseName}_history`);

  // 3. CREATE TABLE 내부 컬럼 추출
  const createTableMatch = ddl.match(/CREATE TABLE IF NOT EXISTS [\s\S]*?\(([\s\S]*?)\)\s*TABLESPACE/);
  if (!createTableMatch) throw new Error("CREATE TABLE 구문을 찾을 수 없음");

  let columns = createTableMatch[1].trim();

  // 4. 기존 PK/Unique/Constraint 제거 (줄 단위)
  columns = columns
    .split("\n")
    .filter(line => !/CONSTRAINT/i.test(line.trim()))
    .join("\n");

  // 5. 히스토리 전용 컬럼 추가 (맨 앞)
  const historyCols = `    his_uuid bigint NOT NULL,
    his_dm timestamp without time zone NOT NULL,
    his_state text COLLATE pg_catalog."default" NOT NULL,`;
  columns = historyCols + "\n    " + columns;

  // 6. CREATE TABLE 정의문 다시 작성
  ddl = ddl.replace(
    /CREATE TABLE IF NOT EXISTS [\s\S]*?\([\s\S]*?\)\s*TABLESPACE/,
    `CREATE TABLE IF NOT EXISTS ${historyTableName}\n(\n${columns}\n    CONSTRAINT ${baseName}_history_pkey PRIMARY KEY (his_dm, his_uuid)\n)\n\nTABLESPACE`
  );

  // 7. COMMENT ON COLUMN: 새 컬럼 추가
  ddl += `
COMMENT ON COLUMN ${historyTableName}.his_uuid IS '변경내역UUID';
COMMENT ON COLUMN ${historyTableName}.his_dm IS '변경일시';
COMMENT ON COLUMN ${historyTableName}.his_state IS '변경상태';
`;

  // 8. COMMENT ON TABLE: _history + ' 변경내역'
  ddl = ddl.replace(
    /COMMENT ON TABLE\s+([^\s]+)\s+IS\s+'([^']+)';/gi,
    (match, tableName, comment) => {
      const historyTable = tableName + "_history";
      return `COMMENT ON TABLE ${historyTable} IS '${comment} 변경내역';`;
    }
  );

            rightText.value = ddl;

            Auto01();
        }
        function Func11() {
let ddl = leftText.value;

// 테이블명 추출
const tableNameMatch = ddl.match(/CREATE TABLE IF NOT EXISTS\s+([^\s(]+)/i);
if (!tableNameMatch) throw new Error("테이블명을 찾을 수 없습니다.");
const fullTableName = tableNameMatch[1];
const baseName = fullTableName.includes(".") ? fullTableName.split(".")[1] : fullTableName;

// 컬럼 추출
const columnsMatch = ddl.match(/CREATE TABLE [\s\S]*?\(([\s\S]*?)\)/i);
if (!columnsMatch) throw new Error("컬럼을 찾을 수 없습니다.");

let columns = columnsMatch[1]
  .split("\n")
  .map(line => line.trim())
  .filter(line => line && !line.toUpperCase().startsWith("CONSTRAINT"))
  .map(line => line.replace(/,$/, ''))
  .map(line => line.split(/\s+/)[0]);

// PK/Unique 컬럼 추출
const pkMatch = ddl.match(/PRIMARY KEY\s*\(([^)]+)\)/i);
const pkCols = pkMatch ? pkMatch[1].split(",").map(c => c.trim()) : [];

const uniqueMatches = [...ddl.matchAll(/UNIQUE\s*\(([^)]+)\)/gi)];
const uniqueCols = uniqueMatches.flatMap(m => m[1].split(",").map(c => c.trim()));

const pkUniqueCols = [...new Set([...pkCols, ...uniqueCols])];

// INSERT 컬럼 (upd_dm, upd_id 제외, reg_dm/NOW() 처리)
const insertCols = columns.filter(c => !["upd_id","upd_dm"].includes(c));
const insertValues = insertCols.map(c => {
  if (c === "reg_dm" || c === "upd_dm") return "NOW()";
  return `p_${c}`;
}).join(",\n        ");

// UPDATE 컬럼 (reg_dm, reg_id 제외, upd_dm/NOW() 처리)
const updateCols = columns.filter(c => !["reg_id","reg_dm"].includes(c));
const updateSet = updateCols.map(c => {
  if (c === "upd_dm") return `${c} = NOW()`;
  return `${c} = p_${c}`;
}).join(",\n        ");

// DISTINCT WHERE 절 (PK/Unique + reg/upd 컬럼 제외)
const distinctCols = columns.filter(c => !pkUniqueCols.includes(c) && !["reg_id","reg_dm","upd_id","upd_dm"].includes(c));
const distinctWhere = distinctCols.map(c => `${fullTableName}.${c} IS DISTINCT FROM p_${c}`).join("\n       OR ");

// p_ 컬럼 정의 (COLLATE 제거, 타입/제약 그대로 유지)
const pColsDef = columnsMatch[1]
  .split("\n")
  .map(line => line.trim())
  .filter(line => line && !line.toUpperCase().startsWith("CONSTRAINT"))
  .map(line => line.replace(/,$/, ''))
  .map(line => {
    let parts = line.replace(/COLLATE pg_catalog\."default"/gi, '').trim();
    let colName = parts.split(/\s+/)[0];
    let colType = parts.slice(colName.length).trim();
    return `p_${colName} ${colType}`;
  })
  .join(",\n    ");

// PERFORM 히스토리용 컬럼 줄바꿈 (p_reg_dm → NOW(), p_upd_dm → NULL)
const performCols = columns.map(c => {
  if (c === "reg_dm") return "NOW()";
  if (c === "upd_dm") return "NULL";
  return `p_${c}`;
}).join(",\n        ");

// 함수 문자열 생성
rightText.value = `
CREATE OR REPLACE FUNCTION public.fn_${baseName}(
    ${pColsDef},
    p_act_type text
)
RETURNS TABLE(r_${columns[0]} bigint)
LANGUAGE plpgsql
AS $BODY$
DECLARE
    v_state text;
    v_action int;
BEGIN
    IF p_${columns[0]} IS NULL THEN
        p_${columns[0]} := seq(); -- 시퀀스 생성
    END IF;

    v_state := UPPER(p_act_type);
    IF v_state = 'D' THEN
        p_inact_yn := 'Y';
    ELSE
        p_inact_yn := 'N';
    END IF;

    INSERT INTO ${fullTableName}(
        ${insertCols.join(",\n        ")}
    )
    VALUES (
        ${insertValues}
    )
    ON CONFLICT ON CONSTRAINT ${baseName}_pkey
    DO UPDATE SET
        ${updateSet}
    WHERE ${distinctWhere}
    RETURNING xmax INTO v_action;

    -- 히스토리 호출
    PERFORM fn_${baseName}_history(
        v_state,
        ${performCols}
    );

    RETURN QUERY
    SELECT p_${columns[0]};

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error: %', SQLERRM;
END;
$BODY$;
`;

            Auto01();
        }
        function Func12() {
let ddl = leftText.value; // ci_asst100 DDL

// 테이블명 추출
const tableNameMatch = ddl.match(/CREATE TABLE IF NOT EXISTS\s+([^\s(]+)/i);
if (!tableNameMatch) throw new Error("테이블명을 찾을 수 없습니다.");
const fullTableName = tableNameMatch[1];
const baseName = fullTableName.includes(".") ? tableNameMatch[1].split(".")[1] : tableNameMatch[1];
const historyTable = `${baseName}_history`;

// 컬럼 추출
const columnsMatch = ddl.match(/CREATE TABLE [\s\S]*?\(([\s\S]*?)\)/i);
if (!columnsMatch) throw new Error("컬럼을 찾을 수 없습니다.");

let columns = columnsMatch[1]
  .split("\n")
  .map(line => line.trim())
  .filter(line => line && !line.toUpperCase().startsWith("CONSTRAINT"))
  .map(line => line.replace(/,$/, ''))
  .map(line => line.split(/\s+/)[0]);

// p_ 컬럼 정의 (COLLATE 제거)
const pColsDef = columnsMatch[1]
  .split("\n")
  .map(line => line.trim())
  .filter(line => line && !line.toUpperCase().startsWith("CONSTRAINT"))
  .map(line => line.replace(/,$/, ''))
  .map(line => {
    let parts = line.replace(/COLLATE pg_catalog\."default"/gi, '').trim();
    let colName = parts.split(/\s+/)[0];
    let colType = parts.slice(colName.length).trim();
    return `p_${colName} ${colType}`;
  })
  .join(",\n    ");

// INSERT 컬럼, VALUES (upd_id, upd_dm 제외, reg_dm → NOW())
const insertCols = ["his_uuid", "his_dm", "his_state", ...columns.filter(c => !["upd_id","upd_dm"].includes(c))];
const insertValues = ["v_his_uuid", "NOW()", "p_his_state", ...columns.filter(c => !["upd_id","upd_dm"].includes(c)).map(c => c === "reg_dm" ? "NOW()" : `p_${c}`)].join(",\n        ");

// 함수 생성
rightText.value = `
CREATE OR REPLACE FUNCTION public.fn_${baseName}_history(
    p_his_state text,
    ${pColsDef}
)
RETURNS TABLE(r_his_uuid bigint) 
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_his_uuid bigint;
BEGIN
    v_his_uuid := ccode();

    INSERT INTO ${historyTable}(
        ${insertCols.join(",\n        ")}
    )
    VALUES (
        ${insertValues}
    );

    RETURN QUERY
    SELECT v_his_uuid;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error: %', SQLERRM;
END;
$BODY$;
`;
            Auto01();
		}
        function Func20() {
            /**
             * 주어진 문자열을 파싱하여 PostgreSQL CREATE TABLE 문과 COMMENT 문을 생성합니다.
             * @param {string} input - 파싱할 문자열.
             * @returns {object} - { createTableQuery, commentQueries } 객체.
             */
            function generateCreateTableAndComments(input) {
              const lines = input.trim().split('\n');
              if (lines.length < 1) {
                return { createTableQuery: '', commentQueries: [] };
              }

              // 첫 번째 줄을 테이블 이름으로 변환 (스네이크 케이스)
              const tableName = ipt_1.value.replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase();
              const unique = tableName.replace(/(^|_)([a-z])[a-z]*/g, "$2")+"_id";
              
              // 컬럼 정보와 코멘트 정보 파싱
              const columns = [];
              const comments = [];
              const columnsHis = [];
              const commentsHis = [];
              
              columns.push(unique + " bigint");
              columnsHis.push("his_uuid bigint NOT NULL");
              columnsHis.push("his_dm timestamp without time zone NOT NULL");
              columnsHis.push("his_state text NOT NULL");
              columnsHis.push(unique + " bigint");
              
              comments.push(`COMMENT ON TABLE ${tableName} IS '${ipt_2.value}';`);
              commentsHis.push(`COMMENT ON TABLE ${ipt_1.value}_history IS '${ipt_2.value} 변경내역';`);
              commentsHis.push(`COMMENT ON COLUMN ${ipt_1.value}_history.his_uuid IS '변경내역UUID';`);
              commentsHis.push(`COMMENT ON COLUMN ${ipt_1.value}_history.his_dm IS '변경일시';`);
              commentsHis.push(`COMMENT ON COLUMN ${ipt_1.value}_history.his_state IS '변경상태(CUD)';`);

              for (let i = 0; i < lines.length; i++) {
                const parts = lines[i].split('\t').map(p => p.trim());
                if (parts.length < 3) continue;

                const columnName = parts[0].toLowerCase();
                const dataType = convertToPostgresType(parts[1]); // PostgreSQL 타입으로 변환
                const comment = parts[4] || parts[2];

                columns.push(`${columnName} ${dataType}`);
                columnsHis.push(`${columnName} ${dataType}`);
                
                comments.push(`COMMENT ON COLUMN ${tableName}.${columnName} IS '${comment}';`);
                commentsHis.push(`COMMENT ON COLUMN ${tableName}_history.${columnName} IS '${comment}';`);
              }

              columns.push("reg_id text");
              columns.push("reg_dm timestamp");
              columns.push("upd_id text");
              columns.push("upd_dm timestamp");
              columns.push("inact_yn text");
              columns.push(`CONSTRAINT ${tableName}_pkey PRIMARY KEY (${ipt_3.value})`);
              columns.push(`CONSTRAINT ${tableName}_${unique}_key UNIQUE (${unique})`);
              columnsHis.push("reg_id text");
              columnsHis.push("reg_dm timestamp");
              columnsHis.push("upd_id text");
              columnsHis.push("upd_dm timestamp");
              columnsHis.push("inact_yn text");
              columnsHis.push(`CONSTRAINT ${ipt_1.value}_history_pkey PRIMARY KEY (his_dm, his_uuid)`);
              
              comments.push(`COMMENT ON COLUMN ${tableName}.reg_id IS '등록자';`);
              comments.push(`COMMENT ON COLUMN ${tableName}.reg_dm IS '등록일시';`);
              comments.push(`COMMENT ON COLUMN ${tableName}.upd_id IS '수정자';`);
              comments.push(`COMMENT ON COLUMN ${tableName}.upd_dm IS '수정일시';`);
              comments.push(`COMMENT ON COLUMN ${tableName}.inact_yn IS '데이터제외구분';`);
              commentsHis.push(`COMMENT ON COLUMN ${tableName}_history.reg_id IS '등록자';`);
              commentsHis.push(`COMMENT ON COLUMN ${tableName}_history.reg_dm IS '등록일시';`);
              commentsHis.push(`COMMENT ON COLUMN ${tableName}_history.upd_id IS '수정자';`);
              commentsHis.push(`COMMENT ON COLUMN ${tableName}_history.upd_dm IS '수정일시';`);
              commentsHis.push(`COMMENT ON COLUMN ${tableName}_history.inact_yn IS '데이터제외구분';`);

              // CREATE TABLE 문 생성
              const createTableQuery = `CREATE TABLE IF NOT EXISTS ${tableName} (\n  ${columns.join(',\n  ')}\n);`;
              const createTableHisQuery = `CREATE TABLE IF NOT EXISTS ${tableName}_history (\n  ${columnsHis.join(',\n  ')}\n);`;

              // 주석 쿼리 문장 생성
              const commentQuery = comments.join('\n');
              const commentHisQuery = commentsHis.join('\n');

              return { createTableQuery, commentQuery, createTableHisQuery, commentHisQuery};
            }

            /**
             * .NET 타입을 PostgreSQL 타입으로 변환합니다.
             * @param {string} dotNetType - .NET 데이터 타입 문자열.
             * @returns {string} - PostgreSQL 데이터 타입 문자열.
             */
            function convertToPostgresType(dotNetType) {
              switch (dotNetType) {
                case 'String':
                    return 'text';
                case 'Int32':
                    return 'integer';
                case 'Int64':
                    return 'bigint';
                case 'Single':
                    return 'real';
                case 'Double':
                    return 'double precision';
                case 'Decimal':
                    return 'numeric';
                case 'Boolean':
                    return 'boolean';
                case 'DateTime':
                case 'DateTimeOffset':
                    return 'timestamp with time zone';
                case 'DateOnly':
                    return 'date';
                case 'TimeOnly':
                    return 'time';
                case 'Guid':
                    return 'uuid';
                case 'List`1':
                    // C# List<T>는 PostgreSQL ARRAY 타입으로 매핑
                    return 'text[]'; // 예시로 text[]를 사용, 실제로는 T에 따라 달라질 수 있음
                case 'Dictionary`2':
                    // Dictionary<TKey, TValue>는 PostgreSQL JSONB로 매핑
                    return 'jsonb';
                default:
                    return dotNetType; // 정의되지 않은 타입
              }
            }
            
            let leftTextVal = leftText.value;
            
            // 함수 실행
            const result = generateCreateTableAndComments(leftTextVal);

            rightText.value = result.createTableQuery + "\n";
            rightText.value += result.commentQuery + "\n";
            rightText.value += result.createTableHisQuery + "\n";
            rightText.value += result.commentHisQuery;

            Auto01();
        }
    </script>
</body>
</html>
